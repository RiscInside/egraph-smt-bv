; <summary>add.egg - addition, subtraction, and negation rules</summary>

; ### Desugaring subtractions and negations

(rewrite (BvSub a b) (BvAdd a (BvNeg b)) :ruleset desugar)
(rewrite (BvNeg e) (BvAdd (BvNot e) (BvConst __1 w)) :when ((= w (Width e))) :ruleset desugar)

(rule ((BvSub a b)) ((delete (BvSub a b))) :ruleset post-desugar)
(rule ((BvNeg e)) ((delete (BvNeg e))) :ruleset post-desugar)

; ### Commutativity

(rewrite (BvAdd a b) (BvAdd b a) :ruleset safe)

; ### Explosive associativity

(rewrite (BvAdd (BvAdd a b) c) (BvAdd a (BvAdd b c)) :ruleset unsafe)

; ### Converting subtraction to negation

(rewrite (BvSub a b) (BvAdd a (BvNeg b)) :replace :ruleset safe)

; ### Double negation elimination

(rewrite (BvNeg (BvNeg a)) a :replace :ruleset safe)

; ### Unfolding one step of `Add`

; Pathological case when bitvector has width 1.

(rewrite (BvAdd a b) (BvXor a b) :replace :when ((= (Width a) 1)) :ruleset safe)

; The rule below does one half-adder step. It is highly explosive.

(rewrite (BvAdd a b) (BvAdd (BvXor a b) (Concat (Extract (- w 2) 0 (BvAnd a b)) (BvAll false 1))) :when ((= w (Width a)) (> (Width a) 1)) :ruleset once)
