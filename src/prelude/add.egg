; <summary>add.egg - addition, subtraction, and negation rules</summary>

; ### Desugaring subtractions to negations

(rewrite (BvSub a b) (BvAdd a (BvNeg b)) :ruleset desugar)
(rule ((BvSub a b)) ((delete (BvSub a b))) :ruleset post-desugar)

; ### Pushing negations down

(rewrite (BvNeg (BvAdd a b)) (BvAdd (BvNeg a) (BvNeg b)) :subsume :ruleset safe)
(rewrite (BvNeg (BvNeg a)) a :subsume :ruleset safe)

; ### Cancellation

(rewrite (BvAdd a (BvNeg a)) (BvConst __0 w) :when ((= w (Width a))) :subsume :ruleset safe)

; ## Going from `BvNeg` to `BvNot` and back

(rewrite (BvNeg e) (BvAdd (BvNot e) (BvConst __1 w)) :when ((= w (Width e))) :ruleset safe)
(rewrite (BvNot e) (BvAdd (BvNeg e) (BvConst (- (<< __1 w) __1) w)) :when ((= w (Width e))) :ruleset safe)

; ### Commutativity

(rewrite (BvAdd a b) (BvAdd b a) :ruleset safe)

; ### Explosive associativity

(rewrite (BvAdd (BvAdd a b) c) (BvAdd a (BvAdd b c)) :ruleset unsafe)

; ### Converting subtraction to negation

(rewrite (BvSub a b) (BvAdd a (BvNeg b)) :replace :ruleset safe)

; ### Double negation elimination

(rewrite (BvNeg (BvNeg a)) a :replace :ruleset safe)

; ### Unfolding one step of `Add`

; Pathological case when bitvector has width 1.

(rewrite (BvAdd a b) (BvXor a b) :replace :when ((= (Width a) 1)) :ruleset safe)

; The rule below does one half-adder step. It is highly explosive.

(rewrite (BvAdd a b) (BvAdd (BvXor a b) (Concat (Extract (- w 2) 0 (BvAnd a b)) (BvAll false 1))) :when ((= w (Width a)) (> (Width a) 1)) :ruleset once)
