; <summary>mul.egg - multiplication rules</summary>

; Multiplying by 0 returns 0
(rewrite (Mul e (BvConst __0 w)) (BvConst __0 w) :subsume :ruleset fold)

; Multiplying by 1 does nothing
(rewrite (Mul e (BvConst __1 w)) e :subsume :ruleset fold)

; Multiplying by -1 is negation
(rewrite (Mul e (BvConst n1 w)) (Neg e) :when ((= w (Width e)) (= (negate __1 w) n1)) :ruleset safe)
(rewrite (Neg e) (Mul e (BvConst (negate __1 w) w)) :when ((= w (Width e))) :ruleset safe)

; Multiplying by 2 is the same as adding twice
(birewrite (Mul e (BvConst __2 w)) (Add e e) :when ((= w (Width e)) (> w 1)) :ruleset fold)

; ### Constant-folding
(rewrite (Mul (BvConst a w) (BvConst b w)) (BvConst (* a b w) w) :subsume :ruleset fold)

; ### Merge-only associativity rules
(rule ((= lhs (Mul a (Mul b c))) (= rhs (Mul (Mul a b) c)) (!= lhs rhs)) ((union lhs rhs)) :ruleset fold)

; ### Commutativity
(rewrite (Mul a b) (Mul b a) :ruleset safe)

; ### Explosive associativity
(birewrite (Mul a (Mul b c)) (Mul (Mul a b) c) :ruleset explosive)

; ### Distributivity
(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)) :ruleset explosive)
(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)) :ruleset slow)

; ### Pushing negations upwards
(rewrite (Mul (Neg a) b) (Neg (Mul a b)) :ruleset explosive)
(rewrite (Mul a (Neg b)) (Neg (Mul a b)) :ruleset explosive)
(rewrite (Mul (Neg a) (Neg b)) (Mul a b) :ruleset fold)

; ### Shift-like Concat into Mul

(rewrite (Concat (Extract (- w (+ shift 1)) 0 a) (BvAll false shift)) (Mul a (BvConst (i64-shl __1 shift w) w)) :when ((= w (Width a))) :ruleset slow)

; The rule below is used to recognise some forms of x << N in yosys. Yosys would often replace shifts with concat of extract
; and zeroes, and, since this extract just goes to the circuit's state bit-vector variable, it would be impossible to pick
; up on it otherwise.

(rule ((= lhs (Concat (Extract i j s) (BvAll false shift)))
       (= rhs (Extract (+ i shift) j s))
       (= w (Width lhs)))
       ((union lhs (Mul rhs (BvConst (i64-shl __1 shift w) w)))) :ruleset slow)

; ### Converting if-then-else into 1 bit multiplication

; This idiom is often used for lowering multiplication bit by bit.

(rewrite (ITE (Extract i i e) e1 (BvAll false w)) (Mul e1 (ZeroExtend (- w 1) (Extract i i e))) :when ((> w 1)) :ruleset slow)
