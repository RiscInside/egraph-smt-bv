; <summary>bpnf.egg - bit propogation normal form rules</summary>

; These rules are based on Concat Normal Form and Bit Propogation Normal Form
; papers. We try to identify things that are roughly similar.

; ### Desugaring some operators

; `Repeat` is just a sequence of `Concat` calls.

(rewrite (Repeat 1 e) e :ruleset desugar)
(rewrite (Repeat n e) (Concat (Repeat (- n 1) e) e) :ruleset desugar :when ((> n 1)))
(rule ((Repeat n e)) ((delete (Repeat n e))) :ruleset post-desugar)

; `RotateLeft` and `RotateRight` by 0 bits does nothing.

(rewrite (RotateLeft 0 e) e :ruleset desugar)
(rewrite (RotateRight 0 e) e :ruleset desugar)

; `RotateLeft` and `RotateRight` by more than `w` bits wraps around.

(rewrite (RotateLeft i e) (RotateLeft (% i w) e) :when ((>= i w) (= w (Width e))) :ruleset desugar)
(rewrite (RotateRight i e) (RotateRight (% i w) e) :when ((>= i w) (= w (Width e))) :ruleset desugar)

; Otherwise, we can lower `RotateLeft` and `RotateRight` as `Concat` of two `Extract`s.

(rewrite (RotateRight i e) (Concat (Extract (- i 1) 0 e) (Extract (- w 1) i e)) :when ((> i 0) (= w (Width e)) (< i w)) :ruleset desugar)
(rewrite (RotateLeft i e) (Concat (Extract (- (- w i) 1) 0 e) (Extract (- w 1) (- w i) e)) :when ((> i 0) (= w (Width e)) (< i w)) :ruleset desugar)

; ### Reassociating concats

(rewrite (Concat a (Concat b c)) (Concat (Concat a b) c) :subsume :ruleset fold)

; ### Pushing extractions through concatenations

(rule ((= e (Extract i j (Concat a b))) (= bw (Width b)) (< i bw))
      ((subsume (Extract i j (Concat a b))) (union e (Extract i j b)))
      :ruleset fold)
(rule ((= e (Extract i j (Concat a b))) (= bw (Width b)) (>= j bw))
      ((subsume (Extract i j (Concat a b))) (union e (Extract (- i bw) (- j bw) a)))
      :ruleset fold)
(rule ((= e (Extract i j (Concat a b))) (= bw (Width b)) (>= i bw) (< j bw))
      ((subsume (Extract i j (Concat a b))) (union e (Concat (Extract (- i bw) 0 a) (Extract (- bw 1) j b))))
      :ruleset fold)

; ### Full width extractions

(rule ((= e (Extract w 0 i)) (= (+ w 1) (Width i))) ((delete (Extract w 0 i)) (union e i)) :ruleset fold)

; ### Concat of two adjacent extractions

(rule ((= e (Concat (Extract i j a) (Extract j k a))))
      ((union e (Extract i k a))
       (subsume (Concat (Extract i j a) (Extract j k a)))) :ruleset fold)

; ### Equality of two concats

; Concat is injective if operands have the same biwidth.

(rule ((= (Concat a b) (Concat c d)) (= (Width a) (Width c))) ((union a c) (union b d)) :ruleset fold)

; This is a more complicated version when a and b have different bitwidths.

(rule ((= (Concat a b) (Concat c d))
       (= aw (Width a)) (= bw (Width b))
       (= cw (Width c)) (= dw (Width d))
       (< bw dw)
      ) (
       (union b (Extract (- bw 1) 0 d))
       (union (Extract (- (- dw bw) 1) 0 a) (Extract (- dw 1) bw d))
       (union c (Extract (- aw 1) (- dw bw) a))
      ) :ruleset safe)

; ### Constant folding for concat/extract

; `Concat` and `Extract` are implemented with bit-shifts on bigints.

(rewrite (Concat (BvConst a w1) (BvConst b w2)) (BvConst (| (<< a w2) b) (+ w1 w2)) :subsume :ruleset fold)
(rewrite (Extract i j (BvConst a w)) (BvConst (& (>> a j) (- (<< __1 i) __1)) (+ 1 (- i j))) :subsume :ruleset fold)
