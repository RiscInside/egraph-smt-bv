; <summary>prelude.egg - essential types/rulesets needed for the solver to function</summary>

; ### Bigint helpers

; We define `__0` and `__1` constants for 0 and 1 bigint values respectively. Those
; are used way too often to type (from-string "0") every single time.

(let __0 (from-string "0"))
(let __1 (from-string "1"))
(let __2 (from-string "2"))

; ### Values (`V`)
; `V` defines all SMT2LIB values. We choose to make values untyped as that
; reduces rule duplication across types.

(sort V)

; We aren't using any "datatype" declaration, as there could be many ways in
; which values in `V` are introduced, some of which we may not even know about.

; ### Value lists/variadics (`VS`)
; `VS` are used for functions accepting variable number of parameters.

(datatype VS (VSCons V VS) (VSNil))

; ### Desugaring ruleset (`desugar`)

; Desugaring ruleset consists of rules for converting one set of primitives
; into another. Converted primitives should never be matched against in other
; rules.
;
; Currently, evaluation rules for user-defined functions are a part of this
; pass, which means that no patterns should be written against user-defined
; functions.
(ruleset desugar)

; There is a helper ruleset `post-desugar` used to cleanup desugared constracts
; and remove them from the e-graph.

(ruleset post-desugar)

; Notably, lists of values are removed in the post-desugaring pass.

(rule ((= l (VSCons v vs))) ((delete (VSCons v vs))) :ruleset post-desugar)
(rule ((= l (VSNil))) ((delete (VSNil))) :ruleset post-desugar)

; ### One-off ruleset (`once`)

; `once` ruleset runs once at the start of the check sat command. It is used for explosive
; rules where it doesn't make sense to apply them multiple times.

(ruleset once)

; ### Folding ruleset (`fold`)

; `fold` ruleset contains rules that reduces e-nodes to their simpler versions.
; This ruleset is meant to make e-graph simpler than it was before folding. `fold`
; ruleset should ideally not introduce new expression e-nodes.

(ruleset fold)

; ### Width ruleset (`width`)

; We define a custom ruleset for width propogation - it runs together with safe
; rules, but it also needs to run prior to desugaring.

(ruleset width)

; ### Equality intro ruleset

; `eq` ruleset allows to go from `Equal x y = true` to `x = y`. This
; effectively allows user to encode any user-defined cycle, so
; only cycle-safe rules should past execution of this ruleset

(ruleset eq)

; ### Saturating ruleset (`safe`)

; `safe` ruleset contains rules that are always eventually saturating. The bar
; for inclusion into `safe` is lower than that for `fold`, so more things can
; go here.

(ruleset safe)

; This ruleset includes:
; * Merge-only rules of any kind (e.g. associativity/commutativity)
; * Constant folding of any kind with subsumption of the original node
; * Cancellation rules (e.g. in `a + b = a` we rewrite `b` to 0 and remove `+`)

; ### Exploratory ruleset (`unsafe`)

; `unsafe` ruleset contrains all other rules that we deem potentially useful.
; These never executed to saturation

(ruleset unsafe)

; ### Visualisation ruleset (`vis`)

; `vis` runs before serializing for e-graph visulisation playground. The goal is to remove
; some junk that makes graph hard to read

(ruleset vis)

; ### `ProvenUnsat`

; `ProvenUnsat` is used to query the system for whether UNSAT status has been shown. Rules can use `(set (ProvenUnsat) true)` to report discovered inconsistency.

(function ProvenUnsat () bool :merge new)
(set (ProvenUnsat) false)
