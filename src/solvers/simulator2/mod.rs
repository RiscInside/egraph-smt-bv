use crate::solvers::{Hypothesis, Variable, Width};
use dag::Dag;
use num_bigint::BigUint;
use rand::{rngs::StdRng, SeedableRng};
use std::collections::VecDeque;

mod dag;
mod lazy_heap;
pub(in crate::solvers) mod mine;
mod skyline;
mod smt;

pub(in crate::solvers) use dag::Operation;

/// Bitvector slice
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub(in crate::solvers) struct Slice {
    pub(in crate::solvers) start: Width,
    pub(in crate::solvers) end: Width,
}

impl From<std::ops::Range<Width>> for Slice {
    fn from(value: std::ops::Range<Width>) -> Self {
        Self {
            start: value.start,
            end: value.end,
        }
    }
}

impl Slice {
    fn subslice(self, subslice: Slice) -> Self {
        Self {
            start: self.start + subslice.start,
            end: self.start + subslice.end,
        }
    }

    fn width(self) -> Width {
        self.end - self.start
    }
}

pub(in crate::solvers) struct SimulationCore<V: Variable> {
    /// Spanning DAG of the e-graph
    dag: Dag<V>,
    /// Pending equivalences to prove
    candidate_hypotheses: VecDeque<Hypothesis<V>>,
    /// Vectors we keep around for resimulation. This set of vectors currently includes
    /// an all zero vector and all SAT vectors generated by Z3
    good_vectors: Vec<BigUint>,
    /// Random number generator for simulation inputs
    rng: rand::rngs::StdRng,
}

impl<V: Variable> Default for SimulationCore<V> {
    fn default() -> Self {
        Self {
            dag: Default::default(),
            candidate_hypotheses: VecDeque::new(),
            good_vectors: Default::default(),
            rng: StdRng::from_seed(Default::default()),
        }
    }
}

impl<V: Variable> SimulationCore<V> {
    pub(in crate::solvers) fn add_input(&mut self, input: V, name: String, width: Width) {
        self.dag.declare_input(input, width, name);
    }

    pub(in crate::solvers) fn add_operation(
        &mut self,
        op: Operation,
        inputs: Vec<V>,
        out: V,
        width: Width,
    ) {
        self.dag.add_equation(op, inputs, out, width);
    }

    pub(in crate::solvers) fn add_extract(&mut self, input: V, slice: Slice, out: V) {
        self.dag.add_extract(input, slice, out);
    }

    pub(in crate::solvers) fn union(&mut self, old: V, new: V) {
        self.dag.union(old, new);
    }

    pub(in crate::solvers) fn summary(&mut self) -> String {
        self.dag.summary()
    }

    pub(in crate::solvers) fn hypotheses_pending(&mut self) -> usize {
        self.candidate_hypotheses.len()
    }
}
