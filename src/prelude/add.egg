; <summary>add.egg - addition, subtraction, and negation rules</summary>

; ### Desugaring subtractions to negations

(rewrite (Sub a b) (Add a (Neg b)) :ruleset desugar)
(rule ((Sub a b)) ((delete (Sub a b))) :ruleset post-desugar)

; ### Cancellation

(rewrite (Add a (Neg a)) (BvConst __0 w) :when ((= w (Width a))) :subsume :ruleset fold)

; ### Adding 0

(rewrite (Add x (BvConst __0 _)) x :subsume :ruleset fold)

; ### Going from `Neg` to `Not` and back

; We can now use `Add` operator to convert between `Neg` and `Not`.

(rewrite (Neg e) (Add (Not e) (BvConst __1 w)) :when ((= w (Width e))) :ruleset explosive)
(rewrite (Not e) (Add (Neg e) (BvConst (negate __1 w) w)) :when ((= w (Width e))) :ruleset explosive)

; ### Constant folding

; Constants can pass through `Add`.

(rewrite (Add (BvConst x w) (BvConst y w)) (BvConst (+ x y w) w) :subsume :ruleset fold)

; Constants can pass through `Neg`.

(rewrite (Neg (BvConst x w)) (BvConst (negate x w) w) :subsume :ruleset fold)

; ### Merge-only associativity

(rule ((= lhs (Add a (Add b c))) (= rhs (Add (Add a b) c)) (!= lhs rhs)) ((union lhs rhs)) :ruleset fold)

; ### Commutativity

(rewrite (Add a b) (Add b a) :ruleset safe)

; To make this rule safe, we need to also discover contradictions in timely matter.

(rule ((= x (Add x (BvConst a _))) (!= a __0)) ((set (ProvenUnsat) true)) :ruleset fold)

; ### Explosive associativity

(rewrite (Add (Add a b) c) (Add a (Add b c)) :ruleset explosive)

; ### Double negation elimination

(rewrite (Neg (Neg a)) a :ruleset fold)

; ### Pushing negations through `Add`

(rewrite (Neg (Add a b)) (Add (Neg a) (Neg b)) :ruleset slow)

; ### Unfolding one step of `Add`

; Pathological case when bitvector has width 1.

(rewrite (Add a b) (Xor a b) :when ((= (Width a) 1)) :ruleset fold)

(rewrite (Add a b) (Add (Xor a b) (Concat (Extract (- w 2) 0 (And a b)) (BvAll false 1))) :when ((= w (Width a)) (> w 1)) :ruleset explosive)

; ### Recovering equivalences from Add

(rule ((= e (Add x z)) (= e (Add y z)) (!= x y)) ((union x y)) :ruleset fold)

; ### Combining zero-extensions

(rewrite (ZeroExtend n1 (ZeroExtend n2 e)) (ZeroExtend (+ n1 n2) e) :subsume :ruleset fold)

; ### Concat is Add, actually

(rewrite (Concat a b) (Add (Mul (ZeroExtend wb a) (BvConst (bit-at wb) (+ wa wb))) (ZeroExtend wa b)) :when ((= wa (Width a)) (= wb (Width b))) :ruleset slow)
