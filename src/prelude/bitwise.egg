; <summary>bitwise.egg - simplifications of boolean/bitwise functions</summary>

; We define a set of rules inspired by AIGs simplifications as seen in
; literature. We are using And/Not constructors directly here instead of
; defining separate AIG ones.

; ### Converting other boolean operators to and/not combinations and back

; We have rules for lowering `Or`, `Xor`, and `Implies` to `Not` and `And`.
; We choose to keep original e-nodes in the e-graph so that rewrite rules can
; still produce those e-nodes when convinient. There is no subsumption either, 
; as aig simplification rules won't get any performance boost from subsuming
; e-nodes from other tables.

(bw-birewrite (or e1 e2) (not (and (not e1) (not e2))))
(bw-rewrite (xor e1 e2)
         (not (and (not (and e1 (not e2))) (not (and (not e1) e2)))))

; `Implies` only exists for booleans.

(rewrite (Implies e1 e2) (Not (And e1 (Not e2))) :ruleset safe)

; `BvNand`, `BvNor`, and `BvXNor` only exist for bitvectors

(rewrite (BvNand e1 e2) (BvNot (BvAnd e1 e2)) :ruleset safe)
(rewrite (BvNor e1 e2) (BvAnd (BvNot e1) (BvNot e2)) :ruleset safe)
(rewrite (BvXNor e1 e2) (BvAnd (BvNot (BvAnd e1 (BvNot e2)))
                        (BvNot (BvAnd (BvNot e1) e2))) :ruleset safe)

; ### `Not` folding

; One rule implicit in AIGs is `Not` folding. We can define this rule to be replacing

(bw-rewrite (not (not a)) a)

; We can propogate constants through `Not`.

(bw-replace (not (lift b)) (lift (not b)))

; ### Bidirectionality of `Not`

; `Not`/`BvNot` is a bijection with itself as an inverse.

(rule ((= (Not x) y)) ((union x (Not y))) :ruleset fold)
(rule ((= (BvNot x) y)) ((union x (BvNot y))) :ruleset fold)

; ### Pushing constant booleans through And

(rule ((= tt (And a b))) ((union tt a) (union tt b)
      (subsume (And a b))) :ruleset fold)
(rule ((= (BvAll true w) (BvAnd a b)) (= w (Width a)))
      ((union (BvAnd a b) a) (union (BvAnd a b) b) (subsume (BvAnd a b)))
      :ruleset fold)

; ### `AIG` simplifications

; These rewrite rules are taken from
; [here](https://cca.informatik.uni-freiburg.de/biere/talks/Biere-GSSLBM06-talk.pdf).

; #### O1 rules

; Note that we already have commutativity, so we don't have to invert those
; patterns.

(bw-replace (and a true) a)
(bw-replace (and a false) false)
(bw-replace (and a a) a)
(bw-replace (and a (not a)) false)

; #### O2 rules

; Contradiction
(bw-replace (and (and (not a) b) a) false)
(bw-replace (and (and a b) (not a)) false)
(bw-replace (and (and a b) (and (not a) c)) false)
; Subsumption
(bw-replace (and (not (and (not a) b)) a) a)
(bw-replace (and (not (and a b)) (not a)) (not a))
(bw-replace (and (not (and (not a) b)) (and a c)) (and a c))
(bw-replace (and (not (and a b)) (and (not a) c)) (and (not a) c))
; Idempotentence
(bw-replace (and (and a b) a) (and a b))
(bw-replace (and (not (and a b)) (not (and a (not b)))) (not a))

; #### O3 rules

(bw-replace (and (not (and a b)) b) (and (not a) b))
(bw-replace (and (not (and a b)) (and b c)) (and (not a) (and b c)))

; #### O4 rules

(bw-replace (and (and a b) (and a d)) (and (and a b) d) (and (and a d) b))

; ### Commutativity of `And`

(bw-rewrite (and a b) (and b a))

; Commutativity of `Or` is derivable.

; ### Associativity of `And` and `Or`

(bw-rewrite-unsafe (and (and a b) c) (and a (and b c)))
(bw-rewrite-unsafe (or (or a b) c) (or a (or b c)))

; ### Distributivity of `And` and `Or`

(bw-birewrite-unsafe (and a (or b c)) (or (and a b) (and a c)))
(bw-birewrite-unsafe (or a (and b c)) (and (or a b) (or a c)))

; ### Constant folding for bit-vectors

; It is sufficient to implement constant folding rules for `BvAnd` and `BvNot`, as all
; other bitwise operators are (sometimes non-destructively) lowered to those.

; `BvAnd` rule is fairly straightforward - we don't have any leading 1 bits.

(rewrite (BvAnd (BvConst a w) (BvConst b _)) (BvConst (& a b) w) :subsume :ruleset fold)

; `BvNot` rule is implemented with XOR to prevent introduction of leading 1 bits.

(rewrite (BvNot (BvConst a w)) (BvConst (^ (- (<< __1 w) __1) a) w) :subsume :ruleset fold)
