; <details>
; <summary>fold.egg - Simple folding rules</summary>

; #### Deriving UNSAT from boolean constant propagation

(rule ((= (B true) (B false))) ((set (ProvenUnsat) true)) :ruleset safe)

; ### Converting all boolean operators to AND and NOT

(rule ((= e (Or e1 e2)))
      ((union e (Not (And (Not e1) (Not e2))))
       (delete (Or e1 e2))) :ruleset desugar)
(rule ((= e (Xor e1 e2)))
      ((union e (Not (And (Not (And e1 (Not e2))) (Not (And (Not e1) e2)))))
       (delete (Xor e1 e2))) :ruleset desugar)
(rule ((= e (Implies e1 e2)))
      ((union e (Not (And e1 (Not e2))))
       (delete (Or e1 e2))) :ruleset desugar)

; ### Boolean operator folding rules

(rewrite (Not (B b)) (B (not b)) :subsume :ruleset safe)
(rewrite (Not (Not e)) e :subsume :ruleset safe)
(rule ((= (Not e) (B b))) ((subsume (Not e)) (union e (B (not b)))) :ruleset safe)

; Note that we have `(and a b)` to `(and b a)` as a `birewrite` in
; `prelude/algebraic.egg`, so we don't need to worry about duplicating patterns
; for `And`.

(rewrite (And e1 tt) e1 :subsume :ruleset safe)
(rewrite (And e1 ff) ff :subsume :ruleset safe)

(rule ((= (And e1 e2) tt))
      ((subsume (And e1 e2)) (union e1 tt) (union e2 tt)) :ruleset safe)

(rewrite (And e e) e :subsume :ruleset safe)
(rewrite (And e1 (Not e1)) ff :subsume :ruleset safe)

; ### Equality rules

(rule ((= tt (Equal e1 e2))) ((union e1 e2)) :ruleset safe)
(rewrite (Equal e e) tt :ruleset safe)
(rewrite (Equal tt ff) ff :ruleset safe)

; ### Bitvector logical operator rules

; These rules mostly resemble boolean equivalents above

(rewrite (BvNot (BvNot e)) e :subsume :ruleset safe)

(rule ((= e (BvOr e1 e2)))
      ((union e (BvNot (BvAnd (BvNot e1) (BvNot e2))))
       (delete (BvOr e1 e2))) :ruleset desugar)
(rule ((= e (BvXor e1 e2)))
      ((union e (BvNot (BvAnd (BvNot (BvAnd e1 (BvNot e2))) (BvNot (BvAnd (BvNot e1) e2)))))
       (delete (BvXor e1 e2))) :ruleset desugar)
(rule ((= e (BvNand e1 e2)))
      ((union e (BvNot (BvAnd e1 e2)))
       (delete (BvOr e1 e2))) :ruleset desugar)
(rule ((= e (BvNor e1 e2)))
      ((union e (BvAnd (BvNot e1) (BvNot e2)))
       (delete (BvNor e1 e2))) :ruleset desugar)
(rule ((= e (BvXNor e1 e2)))
      ((union e (BvAnd (BvNot (BvAnd e1 (BvNot e2))) (BvNot (BvAnd (BvNot e1) e2))))
       (delete (BvXNor e1 e2))) :ruleset desugar)

(rewrite (BvAnd e e) e :subsume :ruleset safe)

; ### Arithmetic folds

(rewrite (BvNeg (BvNeg e)) e :subsume :ruleset safe)

; </details>
