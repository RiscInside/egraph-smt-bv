; <summary>mul.egg - multiplication rules</summary>

; Multiplying by 0 returns 0
(rewrite (Mul e (BvConst __0 w)) (BvConst __0 w) :subsume :ruleset fold)

; Multiplying by 1 does nothing
(rewrite (Mul e (BvConst __1 w)) e :subsume :ruleset fold)

; Multiplying by -1 is negation
(rewrite (Mul e (BvConst n1 w)) (Neg e) :when ((= w (Width e)) (= (negate __1 w) n1)) :ruleset safe)
(rewrite (Neg e) (Mul e (BvConst (negate __1 w) w)) :when ((= w (Width e))) :ruleset safe)

; Multiplying by 2 is the same as adding twice
(birewrite (Mul e (BvConst __2 w)) (Add e e) :when ((= w (Width e)) (> w 1)) :ruleset fold)

; ### Constant-folding
(rewrite (Mul (BvConst a w) (BvConst b w)) (BvConst (* a b w) w) :subsume :ruleset fold)

; ### Merge-only associativity rules
(rule ((= lhs (Mul a (Mul b c))) (= rhs (Mul (Mul a b) c)) (!= lhs rhs)) ((union lhs rhs)) :ruleset fold)

; ### Commutativity
(rewrite (Mul a b) (Mul b a) :ruleset safe)

; ### Explosive associativity
(birewrite (Mul a (Mul b c)) (Mul (Mul a b) c) :ruleset explosive)

; ### Distributivity
(birewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)) :ruleset explosive)

; ### Pushing negations upwards
(rewrite (Mul (Neg a) b) (Neg (Mul a b)) :ruleset explosive)
(rewrite (Mul a (Neg b)) (Neg (Mul a b)) :ruleset explosive)
(rewrite (Mul (Neg a) (Neg b)) (Mul a b) :ruleset fold)

; ### Shift-like Concat into Mul
(rewrite (Concat (Extract (- w (+ shift 1)) 0 a) (BvAll false shift)) (Mul a (BvConst (i64-shl __1 shift w) w)) :when ((= w (Width a))) :ruleset slow)
