; <summary>mul.egg - multiplication rules</summary>

; Multiplying by 0 returns 0
(rewrite (Mul e (BvConst __0 w)) (BvConst __0 w) :subsume :ruleset fold)

; Multiplying by 1 does nothing
(rewrite (Mul e (BvConst __1 w)) e :subsume :ruleset fold)

; Multiplying by -1 is negation
(rewrite (Mul e (BvConst n1 w)) (Neg e) :when ((= w (Width e)) (= (- (<< __1 w) __1) n1)) :ruleset safe)
(rewrite (Neg e) (Mul e (BvConst (- (<< __1 w) __1) w)) :when ((= w (Width e))) :ruleset safe)

; Multiplying by 2 is the same as adding twice
(birewrite (Mul e (BvConst __2 w)) (Add e e) :when ((= w (Width e)) (> w 1)) :ruleset fold)

; Bubbling up constants
(rewrite (Mul (Mul x (BvConst p w)) (BvConst q w)) (Mul x (BvConst (% (* p q) (<< __1 w)) w)) :ruleset safe)

; Combining a*x + x into (a + 1)*x
(rewrite (Add (Mul x (BvConst a w)) x) (Mul x (BvConst (% (+ a __1) (<< __1 w)) w)) :ruleset safe)

; Combining a*x + b*x into (a + b)*x
(rewrite (Add (Mul x (BvConst a w)) (Mul x (BvConst b w))) (Mul x (BvConst (% (+ a b) (<< __1 w)) w)) :ruleset safe)

; ### Constant-folding
(rewrite (Mul (BvConst a w) (BvConst b w)) (BvConst (% (* a b) (<< __1 w)) w) :subsume :ruleset fold)

; ### Merge-only commutativity and associativity rules
(rule ((= lhs (Mul a (Mul b c))) (= rhs (Mul (Mul a b) c))) ((union lhs rhs)) :ruleset fold)
(rule ((= lhs (Mul a b)) (= rhs (Mul b a))) ((union lhs rhs)) :ruleset fold)

; ### Commutativity
(rewrite (Mul a b) (Mul b a) :ruleset safe)

; ### Explosive associativity
(birewrite (Mul a (Mul b c)) (Mul (Mul a b) c) :ruleset unsafe)

; ### Distributivity
(birewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)) :ruleset unsafe)

; ### Pushing negations upwards
(rewrite (Mul (Neg a) b) (Neg (Mul a b)) :ruleset unsafe)
(rewrite (Mul a (Neg b)) (Neg (Mul a b)) :ruleset unsafe)
(rewrite (Mul (Neg a) (Neg b)) (Mul a b) :ruleset fold)

; ### Deducing 0 from equality of Muls
(rule ((= (BvConst __0 w) (Mul a (BvConst v w))) (!= (% v __2) __0)) ((union a (BvConst __0 w))) :ruleset fold)

; ### Shift-like Concat into Mul
(rewrite (Concat (Extract (- w (+ shift 1)) 0 a) (BvAll false shift)) (Mul a (BvConst (% (<< __1 shift) (<< __1 w)) w)) :when ((= w (Width a))) :ruleset safe)
