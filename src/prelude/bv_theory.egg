; <summary>bv_theory.egg - definitions from the SMT2LIB FixedSizeBitVectors theory</summary>

; ### Moving bits around

(constructor Concat (V V) V)
(constructor Extract (i64 i64 V) V)
(constructor Repeat (i64 V) V)
(constructor RotateRight (i64 V) V)
(constructor RotateLeft (i64 V) V)
(constructor ZeroExtend (i64 V) V)
(constructor SignExtend (i64 V) V)

; Rust code lowers variadic `concat` operations to binary `Concat` calls.

; ### Unary bitvector operators

(constructor BvNot (V) V)
(constructor BvNeg (V) V)

; ### Binary bitvector operators

; Some of these support left-associative chaining, but this is handled fully
; by Rust code

; #### Bitwise logical operators

(constructor BvAnd (V V) V)
(constructor BvOr (V V) V)
(constructor BvXor (V V) V)
(constructor BvNand (V V) V)
(constructor BvNor (V V) V)
(constructor BvXNor (V V) V)

; #### Arithmetic operators

(constructor BvAdd (V V) V)
(constructor BvSub (V V) V)
(constructor BvMul (V V) V)
(constructor BvUDiv (V V) V)
(constructor BvURem (V V) V)
(constructor BvSDiv (V V) V)
(constructor BvSRem (V V) V)
(constructor BvSMod (V V) V)

(constructor BvShl (V V) V)
(constructor BvLShr (V V) V)
(constructor BvAShr (V V) V)

; ### Comparison predicates

(constructor BvUle (V V) V)
(constructor BvUlt (V V) V)
(constructor BvUge (V V) V)
(constructor BvUgt (V V) V)
(constructor BvSle (V V) V)
(constructor BvSlt (V V) V)
(constructor BvSge (V V) V)
(constructor BvSgt (V V) V)

; ### Bitvector constants

; `BvConst` defines bitvector constants of a given width.

(constructor BvConst (BigInt i64) V)

; We also define `(BvAll b w)` to represent all-zero/all-one bitvectors
; of width `w` (`b = false` for all-zeros and `b = true` for all-ones).

(constructor BvAll (bool i64) V)

; ### `Width` of bit-vectors

; This function returns width of the bit-vector. Currently it is computed
; bottom-up and returns a single i64 value, but it may be converted to return
; a symbolic value in the future

(function Width (V) i64 :no-merge)

; We define a custom ruleset for width propogation - it runs together with safe
; rules, but it also needs to run prior to desugaring.

(ruleset width)

; #### Propagation rules

; We define width propagation rules for basic primitives. This mostly resemble
; ones implemented in the Rust sort checker.

(rule ((= e (ITE c e1 e2)) (= w1 (Width e1))) ((set (Width e) w1)) :ruleset width)

(rule ((= e (Concat lhs rhs)) (= lw (Width lhs)) (= rw (Width rhs)))
      ((set (Width e) (+ lw rw))) :ruleset width)
(rule ((= e (Extract i j exp))) ((set (Width e) (+ (- i j) 1))) :ruleset width)
(rule ((= e (Repeat n exp)) (= w (Width exp))) ((set (Width e) (* w n))) :ruleset width)
(rule ((= e (RotateLeft _ exp)) (= w (Width exp))) ((set (Width e) w)) :ruleset width)
(rule ((= e (ZeroExtend n exp)) (= w (Width exp))) ((set (Width e) (+ w n))) :ruleset width)
(rule ((= e (SignExtend n exp)) (= w (Width exp))) ((set (Width e) (+ w n))) :ruleset width)

(rule ((= e (BvNot e1)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvNeg e1)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (BvAnd e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvOr e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvXor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvNand e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvNor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvXNor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (BvAdd e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvSub e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvMul e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvUDiv e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvURem e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvSDiv e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvSRem e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvSMod e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvShl e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvLShr e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvAShr e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (BvConst v w))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvAll b w))) ((set (Width e) w)) :ruleset width)

; #### Constants are always positive

; This is a simple check that every computed `BvConst` is positive. Negative signed values should
; be represented as their (positive) twos-complement representation.

(rule ((BvConst a _) (< a __zero)) ((panic "Negative constant detected. This is a constant fold bug")))

; #### Constant folding rules for bitvectors

; Note that we only define folding rules for some operators here, as others can be derived from those.

; `Concat` and `Extract` are implemented with bit-shifts on bigints.

(rewrite (Concat (BvConst a w1) (BvConst b w2)) (BvConst (| (<< a w2) b) (+ w1 w2)) :subsume :ruleset fold)
(rewrite (Extract i j (BvConst a w)) (BvConst (& (>> a j) (- (<< __1 i) __1)) (+ 1 (- i j))) :subsume :ruleset fold)

; `BvAnd` rule is fairly straightforward - we don't have any leading 1 btis.

(rewrite (BvAnd (BvConst a w) (BvConst b _)) (BvConst (& a b) w) :subsume :ruleset fold)

; `BvNot` rule is implemented with XOR to prevent introduction of leading 1 bits.

(rewrite (BvNot (BvConst a w)) (BvConst (^ (- (<< __1 w) __1) a) w) :subsume :ruleset fold)

; `BvAdd` and `BvMul` can be implemented with corresponding unsigned operations. We then need to 
; wrap them around 2^w to ensure canonicity.

(rewrite (BvAdd (BvConst a w) (BvConst b _)) (BvConst (% (+ a b) (<< __1 w)) w) :subsume :ruleset fold)
(rewrite (BvMul (BvConst a w) (BvConst b _)) (BvConst (% (* a b) (<< __1 w)) w) :subsume :ruleset fold)

; `BvUDiv` and `BvURem` are implemented with `/` and `%` as both values are known to be unsigned.
; We need to check for 0 to respect SMT2LIB semantics.

(rewrite (BvUDiv (BvConst a w) (BvConst b _)) (BvConst (/ a b) w) :when ((!= b __0)) :subsume :ruleset fold)
(rewrite (BvURem (BvConst a w) (BvConst b _)) (BvConst (% a b) w) :when ((!= b __0)) :subsume :ruleset fold)

; Different bitvectors are not equal.

(rewrite (Equal (BvConst a w) (BvConst b _)) ff :when ((!= a b)) :subsume :ruleset fold)
