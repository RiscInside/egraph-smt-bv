; <summary>add.egg - addition, subtraction, and negation rules</summary>

; ### Desugaring subtractions to negations

(rewrite (BvSub a b) (BvAdd a (BvNeg b)) :ruleset desugar)
(rule ((BvSub a b)) ((delete (BvSub a b))) :ruleset post-desugar)

; ### Pushing negations down

(rewrite (BvNeg (BvAdd a b)) (BvAdd (BvNeg a) (BvNeg b)) :subsume :ruleset safe)
(rewrite (BvNeg (BvNeg a)) a :subsume :ruleset safe)

; ### Cancellation

(rewrite (BvAdd a (BvNeg a)) (BvConst __0 w) :when ((= w (Width a))) :subsume :ruleset fold)

; ## Going from `BvNeg` to `BvNot` and back

(rewrite (BvNeg e) (BvAdd (BvNot e) (BvConst __1 w)) :when ((= w (Width e))) :ruleset safe)
(rewrite (BvNot e) (BvAdd (BvNeg e) (BvConst (- (<< __1 w) __1) w)) :when ((= w (Width e))) :ruleset safe)

; ### Commutativity

(rewrite (BvAdd a b) (BvAdd b a) :ruleset safe)

; ### Explosive associativity

(rewrite (BvAdd (BvAdd a b) c) (BvAdd a (BvAdd b c)) :ruleset unsafe)

; ### Double negation elimination

(rewrite (BvNeg (BvNeg a)) a :subsume :ruleset fold)

; ### Unfolding one step of `Add`

; Pathological case when bitvector has width 1.

(rewrite (BvAdd a b) (BvXor a b) :subsume :when ((= (Width a) 1)) :ruleset fold)

; The rule below does one half-adder step. It is highly explosive, so it goes into `once` ruleset - it is unlikely we will get a lot from applying it more than once.

(rewrite (BvAdd a b) (BvAdd (BvXor a b) (Concat (Extract (- w 2) 0 (BvAnd a b)) (BvAll false 1))) :when ((= w (Width a)) (> w 1)) :ruleset once)

; ### Pushing down equality of `add` and `neg`

(rewrite (Equal (BvAdd x y) (BvAdd y z)) (Equal x z) :ruleset safe)
(rewrite (Equal (BvAdd x y) (BvAdd x z)) (Equal y z) :ruleset safe)
(rewrite (Equal (BvNeg x) (BvNeg y)) (Equal x y) :ruleset safe)
