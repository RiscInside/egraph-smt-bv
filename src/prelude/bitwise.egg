; <summary>bitwise.egg - simplifications of boolean/bitwise functions</summary>

; We define a set of rules inspired by AIGs simplifications as seen in
; literature. We are using And/Not constructors directly here instead of
; defining separate AIG ones.

; ### Converting other boolean operators to and/not combinations and back

; We have rules for lowering `Or`, `Xor`, and `Implies` to `Not` and `And`.
; We choose to keep original e-nodes in the e-graph so that rewrite rules can
; still produce those e-nodes when convenient. There is no subsumption either, 
; as aig simplification rules won't get any performance boost from subsuming
; e-nodes from other tables.

(birewrite (Or e1 e2) (Not (And (Not e1) (Not e2))) :ruleset fold)
(rewrite (Xor e1 e2)
         (Not (And (Not (And e1 (Not e2))) (Not (And (Not e1) e2)))) :ruleset fold)
(rewrite (Implies e1 e2) (Not (And e1 (Not e2))) :ruleset fold)
(rewrite (Nand e1 e2) (Not (And e1 e2)) :ruleset fold)
(rewrite (Nor e1 e2) (And (Not e1) (Not e2)) :ruleset fold)
(rewrite (XNor e1 e2) (And (Not (And e1 (Not e2)))
                        (Not (And (Not e1) e2))) :ruleset fold)

; ### `Not` folding

; One rule implicit in AIGs is `Not` folding.

(rewrite (Not (Not a)) a :ruleset fold)

; We can propagate constants through `Not`.

(rewrite (Not (BvAll b w)) (BvAll (not b) w) :ruleset fold)

; ### Bidirectionality of `Not`

; `Not` is a bijection with itself as an inverse.

(rule ((= (Not x) y)) ((union x (Not y))) :ruleset fold)

; ### Pushing constant booleans through And

(rule ((= (BvAll true w) (And a b)) (= w (Width a)))
      ((union (And a b) a) (union (And a b) b) (subsume (And a b)))
      :ruleset fold)

; ### `AIG` simplifications

; These rewrite rules are taken from
; [here](https://cca.informatik.uni-freiburg.de/biere/talks/Biere-GSSLBM06-talk.pdf).

; #### O1 rules

; Note that we already have commutativity, so we don't have to invert those
; patterns.

(rewrite (And a (BvAll true _)) a :subsume :ruleset fold)
(rewrite (And a (BvAll false w)) (BvAll false w) :subsume :ruleset fold)
(rewrite (And (BvAll true _) a) a :subsume :ruleset fold)
(rewrite (And (BvAll false w) a) (BvAll false w) :subsume :ruleset fold)
(rewrite (And a a) a :subsume :ruleset fold)
(rewrite (And a (Not a)) (BvAll false w) :when ((= w (Width a))) :subsume :ruleset fold)
(rewrite (And (Not a) a) (BvAll false w) :when ((= w (Width a))) :subsume :ruleset fold)

; #### O2 rules

; Contradiction

(rewrite (And (And (Not a) b) a) (BvAll false w) :when ((= w (Width a))) :subsume :ruleset fold)
(rewrite (And (And a b) (Not a)) (BvAll false w) :when ((= w (Width a))) :subsume :ruleset fold)
(rewrite (And (And a b) (And (Not a) c)) (BvAll false w) :when ((= w (Width a))) :subsume :ruleset fold)

; Subsumption

(rewrite (And (Not (And (Not a) b)) a) a :subsume :ruleset fold)
(rewrite (And (Not (And a b)) (Not a)) (Not a) :subsume :ruleset fold)
(rewrite (And (Not (And (Not a) b)) (And a c)) (And a c) :ruleset fold)
(rewrite (And (Not (And a b)) (And (Not a) c)) (And (Not a) c) :ruleset fold)

; Idempotence

(rewrite (And (And a b) a) (And a b) :ruleset fold)
(rewrite (And (Not (And a b)) (Not (And a (Not b)))) (Not a) :subsume :ruleset fold)

; #### O3 rules

(rewrite (And (Not (And a b)) b) (And (Not a) b) :ruleset fold)
(rewrite (And (Not (And a b)) (And b c)) (And (Not a) (And b c)) :ruleset fold)

; #### O4 rules

(rule ((= e (And (And a b) (And a d))))
      ((union e (And (And a b) d))
       (union e (And (And a d) b)))
      :ruleset fold)

; ### Commutativity of `And`

(rewrite (And a b) (And b a) :ruleset safe)

; Commutativity of `Or` is derivable.

; ### Associativity of `And` and `Or`

(rewrite (And (And a b) c) (And a (And b c)) :ruleset unsafe)
(rewrite (Or (Or a b) c) (Or a (Or b c)) :ruleset unsafe)

; ### Distributivity of `And` and `Or`

(birewrite (And a (Or b c)) (Or (And a b) (And a c)) :ruleset unsafe)
(birewrite (Or a (And b c)) (And (Or a b) (Or a c)) :ruleset unsafe)

; ### Constant folding for bit-vectors

; It is sufficient to implement constant folding rules for `And` and `Not` on bitvectors - all
; other bitwise operators are (sometimes non-destructively) lowered to those.

; `And` rule is fairly straightforward - we don't have any leading 1 bits.

(rewrite (And (BvConst a w) (BvConst b _)) (BvConst (& a b) w) :subsume :ruleset fold)

; `Not` rule is implemented with XOR to prevent introduction of leading 1 bits.

(rewrite (Not (BvConst a w)) (BvConst (^ (- (<< __1 w) __1) a) w) :subsume :ruleset fold)
