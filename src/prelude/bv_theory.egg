; <summary>bv_theory.egg - definitions from the SMT2LIB FixedSizeBitVectors theory</summary>

; ### Moving bits around

(constructor Concat (V V) V)
(constructor Extract (i64 i64 V) V)
(constructor Repeat (i64 V) V)
(constructor RotateRight (i64 V) V)
(constructor RotateLeft (i64 V) V)
(constructor ZeroExtend (i64 V) V)
(constructor SignExtend (i64 V) V)

; Rust code lowers variadic `concat` operations to binary `Concat` calls.

; ### Unary bitvector negation

(constructor Neg (V) V)

; Bitwise NOT is already supported by overloading `Not`.

; ### Binary bitvector operators

; Some of these support left-associative chaining, but this is handled fully
; by Rust code

; #### Bitwise logical operators

(constructor Nand (V V) V)
(constructor Nor (V V) V)
(constructor XNor (V V) V)

; #### Arithmetic operators

(constructor Add (V V) V)
(constructor Sub (V V) V)
(constructor Mul (V V) V)
(constructor UDiv (V V) V)
(constructor URem (V V) V)
(constructor SDiv (V V) V)
(constructor SRem (V V) V)
(constructor SMod (V V) V)

(constructor Shl (V V) V)
(constructor LShr (V V) V)
(constructor AShr (V V) V)

; ### Comparison predicates

(constructor Ule (V V) V)
(constructor Ult (V V) V)
(constructor Uge (V V) V)
(constructor Ugt (V V) V)
(constructor Sle (V V) V)
(constructor Slt (V V) V)
(constructor Sge (V V) V)
(constructor Sgt (V V) V)

; ### Bitvector constants

; `BvConst` defines bitvector constants of a given width.

(constructor BvConst (BigInt i64) V)

; We also define `(BvAll b w)` to represent all-zero/all-one bitvectors
; of width `w` (`b = false` for all-zeros and `b = true` for all-ones).

(constructor BvAll (bool i64) V)

; `(BvAll false w)` is equivalent to `(BvConst 0 _w)

(birewrite (BvAll false w) (BvConst __0 w) :ruleset fold)

; #### Constants are always positive

; This is a simple check that every computed `BvConst` is positive. Negative signed values should
; be represented as their (positive) twos-complement representation.

(rule ((BvConst a _) (< a __0)) ((panic "Negative constant detected. This is a constant fold bug")))

; #### Different constants are not equal.

(rewrite (Equal (BvConst a w) (BvConst b _)) ff :when ((!= a b)) :subsume :ruleset fold)

; ### `Width` of bit-vectors

; This function returns width of the bit-vector. Currently it is computed
; bottom-up and returns a single i64 value, but it may be converted to return
; a symbolic value in the future

(function Width (V) i64 :no-merge)

; We define a custom ruleset for width propogation - it runs together with safe
; rules, but it also needs to run prior to desugaring.

(ruleset width)

; #### Propagation rules

; We define width propagation rules for basic primitives. This mostly resemble
; ones implemented in the Rust sort checker.

(rule ((= e (ITE c e1 e2)) (= w1 (Width e1))) ((set (Width e) w1)) :ruleset width)

(rule ((= e (Concat lhs rhs)) (= lw (Width lhs)) (= rw (Width rhs)))
      ((set (Width e) (+ lw rw))) :ruleset width)
(rule ((= e (Extract i j exp))) ((set (Width e) (+ (- i j) 1))) :ruleset width)
(rule ((= e (Repeat n exp)) (= w (Width exp))) ((set (Width e) (* w n))) :ruleset width)
(rule ((= e (RotateLeft _ exp)) (= w (Width exp))) ((set (Width e) w)) :ruleset width)
(rule ((= e (ZeroExtend n exp)) (= w (Width exp))) ((set (Width e) (+ w n))) :ruleset width)
(rule ((= e (SignExtend n exp)) (= w (Width exp))) ((set (Width e) (+ w n))) :ruleset width)

(rule ((= e (Not e1)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Neg e1)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (And e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Or e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Xor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Nand e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Nor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (XNor e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (Add e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Sub e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Mul e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (UDiv e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (URem e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (SDiv e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (SRem e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (SMod e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (Shl e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (LShr e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)
(rule ((= e (AShr e1 e2)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

(rule ((= e (BvConst v w))) ((set (Width e) w)) :ruleset width)
(rule ((= e (BvAll b w))) ((set (Width e) w)) :ruleset width)

; Note that we only define folding rules for some operators here, as others can be derived from those.
