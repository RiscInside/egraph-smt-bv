; <summary>add.egg - addition, subtraction, and negation rules</summary>

; ### Desugaring subtractions to negations

(rewrite (Sub a b) (Add a (Neg b)) :ruleset desugar)
(rule ((Sub a b)) ((delete (Sub a b))) :ruleset post-desugar)

; ### Pushing negations down

(rewrite (Neg (Add a b)) (Add (Neg a) (Neg b)) :subsume :ruleset safe)
(rewrite (Neg (Neg a)) a :subsume :ruleset safe)

; ### Cancellation

(rewrite (Add a (Neg a)) (BvConst __0 w) :when ((= w (Width a))) :subsume :ruleset fold)

; ### Constant addition

; Negation <-> bitwise-not rules produce many +1/-1 additions. Those are then combined in many
; different ways by associativity/commutativity rewrites for addition, causing the e-graph to
; blow up.

; To solve this, we add a custom operator for adding constants that can be pushed upwards
; through `Add` and `Neg`.

(constructor AddC (V BigInt) V)

(rule ((= e (AddC e1 _)) (= w (Width e1))) ((set (Width e) w)) :ruleset width)

; We convert constant additions to `AddC`.

(rewrite (Add x (BvConst v _)) (AddC x v) :subsume :ruleset fold)
(rewrite (Add (BvConst v _) x) (AddC x v) :subsume :ruleset fold)

; Adding 0 has no effect.

(rewrite (AddC x __0) x :subsume :ruleset fold)

; We can collapse multiple `AddC`s together.

(rewrite (AddC (AddC x p) q) (AddC x (% (+ p q) (<< __1 w))) :when ((= w (Width x))) :subsume :ruleset fold)

; `AddC` can travel through `Add`.

(rewrite (Add (AddC x v) y) (AddC (Add x y) v) :ruleset safe)
(rewrite (Add x (AddC y v)) (AddC (Add x y) v) :ruleset safe)

; `AddC` can also travel through `Neg`.

(rewrite (Neg (AddC x v)) (AddC (Neg x) (- (<< __1 w) v)) :when ((= w (Width x))) :ruleset safe)

; `AddC` can go in both directions.

(rule ((= x (AddC y v)) (= w (Width y))) ((union y (AddC x (- (<< __1 w) v)))) :ruleset safe)

; ### Going from `Neg` to `Not` and back

; We can now use `AddC` operator to lower `Neg` and `Not`.

(rewrite (Neg e) (AddC (Not e) __1) :ruleset safe)
(rewrite (Not e) (AddC (Neg e) (- (<< __1 w) __1)) :when ((= w (Width e))) :ruleset safe)

; ### Constant folding

; Constants can pass through `AddC`. 

(rewrite (AddC (BvConst x w) y) (BvConst (% (+ x y) (<< __1 w)) w) :ruleset fold)

; ### Commutativity

(rewrite (Add a b) (Add b a) :ruleset safe)

; ### Explosive associativity

(rewrite (Add (Add a b) c) (Add a (Add b c)) :ruleset unsafe)

; ### Double negation elimination

(rewrite (Neg (Neg a)) a :subsume :ruleset fold)

; ### Unfolding one step of `Add`

; Pathological case when bitvector has width 1.

(rewrite (Add a b) (Xor a b) :subsume :when ((= (Width a) 1)) :ruleset fold)

; The rule below does one half-adder step. It is highly explosive, so it goes into `once` ruleset - it is unlikely we will get a lot from applying it more than once.

(rewrite (Add a b) (Add (Xor a b) (Concat (Extract (- w 2) 0 (And a b)) (BvAll false 1))) :when ((= w (Width a)) (> w 1)) :ruleset once)

; ### Recovering equivalences from Add

(rule ((= (Add x z) (Add y z))) ((union x y)) :ruleset fold)

; ### Combining zero-extensions

(rewrite (ZeroExtend n1 (ZeroExtend n2 e)) (ZeroExtend (+ n1 n2) e) :subsume :ruleset fold)

; ### Pushing zero-extensions outwards

(rewrite (ZeroExtend n (Add (ZeroExtend n1 a) (ZeroExtend n2 b))) (Add (ZeroExtend (+ n n1) a) (ZeroExtend (+ n n2) b)) :ruleset safe)

; ### Pushing zero-extensions inwards

(rewrite (Add (ZeroExtend n1 e1) (ZeroExtend n2 e2)) (ZeroExtend (- n1 1) (Add (ZeroExtend 1 e1) (ZeroExtend (- n2 (- n1 1)) e2))) :ruleset safe :when ((<= n1 n2) (< 1 n1)))
